---
author: "Jan Verbesselt, Jorge Mendes de Jesus, Aldo Bergsma, Johannes Eberenz, Dainius Masiliunas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Week 3: Python for geo-scripting"
    theme: "simplex"
    highlight: Tomorrow Night Bright
    menu: FALSE
    theme.chooser: TRUE
    highlight.chooser: TRUE
---

# [WUR Geoscripting](https://geoscripting-wur.github.io/) <img src="http://www.wur.nl/upload/b43b7095-e452-482a-8969-fed9a50393a8_WUR_RGB_standard.png" alt="WUR logo" style="height: 35px;"/>

# "Week 3: Python for Geo-scripting"

Good morning! Today we will start working with Python for Geo-scripting and do a refresher of functions in Python. First complete the Intro to Python for Data Science course in Datacamp and then go through today's tutorial.

### Today's schedule

- Follow DataCamp Intro to Python for Data Science course
- Get Introduced to Python Environment
- Learn how to work with virtual environments: Conda
- Learn how to create Jupyter Notebook
- Refresh Python programming knowledge
- Check a nice example of a Jupyter Notebook


## Introduction to Python Environment
Python is a jack-of-all-trades programming language, that is free, flexible, open-source, cross-platform and has a very large community behind it. If you ask Python programmers what they like most about Python, they will often cite its high readability and high availability of good packages. There is a lot of awesome Python packages out there for geo-scripting, data wrangling, visualization and machine learning:

* Geo Scripting
    * GeoPandas (Vector Processing)
    * RasterIO (Raster Processing)
    * GDAL/OGR (Vector and Raster Processing)
    * QGIS (Open Source GIS)
    * ArcPy (Propietary GIS)
* Data Wrangling
    * Pandas (Dataframes and Data Analysis)
    * Numpy (Scientific Computing)
* Visualization
    * Matplotlib (General Graphics)
    * Seaborn (Statistical Graphics)
    * Folium (Interactive Maps)
* Machine Learning
    * TensorFlow (Deep Learning)
    * Keras (Deep/Machine Learning)
    * Scikit-Learn (Machine Learning)



### Python editors and IDEs
There are a number of proper Integrated Development Environments [IDE] for Python. An IDE is a software application that provides facilities for software development.

* [Spyder](https://www.spyder-ide.org/) is nice a lightweight IDE and can be installed from the terminal. In the Geo-scripting course Spyder is recommended as Python IDE.
* [Jupyter Notebook](http://jupyter.org/) integrates visualizations together with code and is highly suitable to make tutorials or simple dashboards. Jupyter Notebooks run in your browser and are not recommended during large professional projects, because they don't have good versioning, no IDE integration and no code-style correction. Today the Jupyter Notebook will be used and explained.
* [PyCharm](https://www.jetbrains.com/pycharm/) is a free professional Python IDE with a lot of advanced functionality, such as integrated GIT version control and navigation. This IDE is not recommended during the Geo-scripting course since we want to focus on learning Geo-scripting and not learning an IDE, but we do want you to know there are more professional IDE out there.



### Python package management
A set of tools co-exist for installing and managing packages. You don't want to bloat your computer with all kinds of Python packages. This will definitely break some of your Python projects sooner or later since packages have varying dependencies. So instead per project an environment is created on your local machine, where Python packages can be installed and organized. For each project it is recommended to make a new environment. There are three ways to install packages sorted from most preferred to less preferred:

* Using [conda](https://conda.io/docs/user-guide/tasks/manage-pkgs.html) to install packages and to keep separate sets of packages. A set of of packages in `Conda` is called a conda environment. `Conda` is available for Windows, macOS and Linux. You can also have conda environments for C libraries, or R packages, or really anything.
* Using `pip` to install packages and `conda` to manage packages. `Pip` is available for Windows, macOS and Linux. Pip sometimes is the better way to install packages and can install [binary wheels on Windows](https://www.lfd.uci.edu/~gohlke/Pythonlibs).
* Using the distribution's package manager (only on Ubuntu, that's `sudo apt-get install Python-*`).

#### Conda installation
Conda can be downloaded in two versions: Anaconda and Miniconda. The difference is that Miniconda is just shipping the repository management system. So when you install it there is just the management system without packages. Whereas with Anaconda, it is like a distribution with some built in packages. 
In Geo-scripting Miniconda is used. To install Miniconda in your Linux environment, we have prepared a short *Bash* script for you. Just run the following lines of code, line by line, in a new terminal window.

```{r, eval=FALSE, engine='bash'}
MINICONDA_VERSION="Miniconda3-latest-Linux-x86_64"
pushd /tmp
curl -O https://repo.continuum.io/miniconda/${MINICONDA_VERSION}.sh
## This installation script will require user input
bash ${MINICONDA_VERSION}.sh
rm ${MINICONDA_VERSION}.sh
popd
```

When prompted, you can just use the default options (i.e. press Enter). When prompted to replace the default Python interpreter in your system with Conda interpreter, you should say `Yes` in the last prompt. Finally, restart your terminal to be able to use conda in the terminal.

#### Conda usage
Go to your terminal and type in:

```{r, eval=FALSE, engine='bash'}
conda search spyder
```

This gives a list of all packages that have "Spyder" in the name and lists all available versions. To install:

```{r, eval=FALSE, engine='bash'}
conda install spyder
```

This would install the latest version of the `Spyder` package (Python IDE). Note that this would install it into your user's root virtual environment (by default it is `$HOME/miniconda3`). Conda creates isolated environments with sets of packages, that do not interfere with your base Python or with other conda environments. To create an environment:

```{r, eval=FALSE, engine='bash'}
conda create --name geotest Python=2.7 numpy
```

This would create a new environment called `geotest` with Python 2.7 and `numpy` installed into the conda environment. To list the available environments:

```{r, eval=FALSE, engine='bash'}
conda info --envs
```

Conda puts an asterisk (*) in front of the active environment. Activate the environment.

```{r, eval=FALSE, engine='bash'}
## Cross-platform
conda activate geotest
## Linux, macOS
source activate geotest
## Windows
activate geotest
```

After this, the current environment is shown in (parentheses) in front of your prompt (`(geotest)$`). Note that the activated environment is only valid for the shell in which you activated it. For instance, if you close the shell window and open a new one you will have to activate it again. If you want to install a new package and are inside the conda environment, the package is installed simply with conda or pip. Conda is recommended.

```{r, eval=FALSE, engine='bash'}
conda install geopandas pandas
pip install rasterio rasterstats
```

Removing is just as simple.

```{r, eval=FALSE, engine='bash'}
conda remove geopandas pandas
pip uninstall rasterio rasterstats
```

Now deactivate the environment and return to base environment.

```{r, eval=FALSE, engine='bash'}
## Cross-platform
conda deactivate
## Linux, macOS
source deactivate
## Windows
deactivate
```

Since Python 2.7 is outdated and we want to work with Python 3, we can remove the environment `geotest`.

```{r, eval=FALSE, engine='bash'}
conda remove --name geotest --all
```

In addition, as you saw with Spyder install, Conda is able to install some non-Python packages that have Python bindings, such as Spyder and GDAL. This is useful for making sure your Python and binary versions match and do not interfere with the system-wide ones. To run e.g. Spyder from within a conda environment called ide, you would need to do something like this:

```{r, eval=FALSE, engine='bash'}
conda activate ide
spyder
```

Some extra helpful utilities are:

* `conda list` to check which packages are installed in `root` or in the active environment;
* `Python --version` or `gdal-config --version` to check which verison is used in the environment;
* `which spyder` or `type spyder` to find out which Spyder executable is used either from system or conda environment.


## Running Python in terminal

For quick testing, Python can be started from terminal in Linux.

```{r, eval=FALSE, engine='bash'}
Python
# or 
Python2
# or 
Python3
```

Test this script and find out what your Python version is inside Python. Wow!

```{Python, eval=FALSE, engine.path='/usr/bin/Python3'}
import sys
print('Good morning, you are running Python:', sys.version)
```

Okay enough fooling around. Time for some proper IDEs. Exit Python in the terminal to return to your normal terminal.
```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
exit()
# or 
quit()
```

## Running Python in Jupyter Notebooks

Jupyter Notebooks make coding in Python much easier and allow for nice integrated visualizations. Try the following commands in your terminal to create a conda environment with Jupyter Notebook:

```{r, eval=FALSE, engine='bash'}
conda create -n geoscripting numpy jupyter folium
conda activate geoscripting
conda install --channel conda-forge folium
```

Sometimes packages are not directly available from standard conda channel, but require a specific conda channel to install package from, such as conda-forge. In the documentation of most Python packages the recommended way to install can be found.

Time to run the Jupyter Notebook and be amazed.

```{r, eval=FALSE, engine='bash'}
cd
jupyter notebook
```

If everything goes according to plan, Jupyter will pop up in your browser. You will see a menu with all the files in your working directory. The Jupyter Notebook will only see files that are accessible from the working directory in which you launched the notebook!

Go to documents. Make a new folder: *New* → *Folder*, rename the folder and create new Python3 Jupyter Notebook *New* → *Python 3*. Give your notebook a name by clicking on untitled. Feel free to have a go at the user interface tour: *Help* → *User Interface Tour*.

Hover over the toolbar to check out all tools. These are the basic tools you will need today:

- `Save and checkpoint`
- `Insert cell below`
- `Run`
- `Code/Markdown/Heading` (List box)

Similar to RMarkdown, Jupyter Notebooks has code cells (*Code*) and text cells (*Markdown*). Insert some extra cells by clicking the + button and change the first cell from code to markdown. Enter some documentation for your code (e.g. your team name, exercise and date). Leave the other cells on code. Type following Python code in a code cell:

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
import folium
m = folium.Map(location=[51.9700000, 5.6666700], zoom_start=13)
m
```

Run the code in a code cell, select it and press the *Run* button, or press *CTRL + Enter* or *Shift + Enter*. Nice map huh .. in just three lines of code. Isn't that easy.



## Python refresher

Python has a way of doing things. It is called the Pythonic way: simple readable code.

### Looking for help

If you are looking for help while programming in Python, there are several ways to find help. Usually googling solves your problem the quickest, because it finds answers on multiple platforms, such as StackOverflow and Github. During Geo-scripting we have the forum to ask and give help. Asking your friends or colleagues in person is also a great way to learn and fix programming problems. Another good option is get documentation from the package website or inside Python.

```{Python, engine.path='/usr/bin/Python3'}
import sys
help(sys)
```

See how the functions in the `sys` package got listed.

> **Question** 1: What does this mean `__ __` around words: e.g: `__doc__`?


### Numbers and variables


```{Python, engine.path='/usr/bin/Python3'}
print(int(10.6))
```

> **Question 2**: What is the difference between 10 and 10.0 when dealing with data types in Python?

Variable is a storage location or symbolic name to a value e.g.:

```{Python, engine.path='/usr/bin/Python3'}
building = 'Gaia'
buildingNumber = 101
building + ' is in Wageningen'
```

There is no need to define the datatype, `Python` has a loose datatype variable declaration. Python is basically a list of objects.


### Lists
Now we will have a go with lists.

**Tip**: Variables, functions, classes and methods that you define in one of your Jupyter Notebook cells can be used in other cells too.

Run this code in one cell.
```{Python, engine.path='/usr/bin/Python3'}
campus = ['Gaia', 'Lumen', 'Radix', 'Forum']
# how to can we print Forum?
print(campus[3])
# how to access the end of the list (while having no idea how big it is)
print(campus[-1])
# how to access the first 3 items
print(campus[0:3])
```

Play around with this code in another cell. We will do some appending, inserting, extending and steps:
```{Python, engine.path='/usr/bin/Python3'}
campus.append("Atlas")
campus.insert(1,"SoilMuseum")
campus.extend(["Action", "Vitae", "Zodiac"])
print(campus)
print(campus[::2])
```

See how the notebook remembered how you set the variable `campus`. 

> **Question 3:** What are the major differences between Append/Extend?

> **Question 4:** What building is `campus[-2]`?

### Dictionaries, loops, if/else

Let there be dictionaries... A dictionary is an unordered set of key:value pairs. Like in the dictionary, 'food':'voedsel'.

```{Python, engine.path='/usr/bin/Python3'}
campusDictionary = {101:'Gaia',
                    100:'Lumen',
                    107:'Radix',
                    102:'Forum',
                    104:'Altas'}
print(campusDictionary[102])
```

Loops: watch out here with code indentation. Python uses indentation to define code blocks and not `{}` like other languages. Indentation is either 1 tab or 4 spaces.

```{Python, engine.path='/usr/bin/Python3'}
campus = ['Gaia','Lumen', 'Radix', 'Forum']
for building in campus:
    print(building)
```

Generic loops in Python have to interact over a sequence of objects e.g.

```{Python, engine.path='/usr/bin/Python3'}
range(5)
for number in range(5):
    print(number)
```

Object interaction and functional programming is an important part of Python programming and its tools are extensive.
`if`/`else`:

```{Python, engine.path='/usr/bin/Python3'}
x = 3
if x == 1:
    print("it is one")
elif x == 2:
    print("it is two")
elif x == 3:
    print("it is three")
else: 
    print("above 3")
```

### Functions

A function is a section of code that does something specific that you want to use multiple times without having to type the full function again but just call the function by its name. Functions accept arguments and return variables e.g.:

```{Python, engine.path='/usr/bin/Python3'}
def printHelloName(name):
    print("Good morning " + name)

printHelloName(name="Jan")
```

`return` is used to indicate what you want to obtain from the function, you can `return` multiple items and return can be used to assign output to variables outside of the function. 

```{Python, engine.path='/usr/bin/Python3'}
def times3(input_number):
    output_number = input_number * 3
    return output_number, input_number
    
print(times3(input_number=4))

output_number, input_number = times3(input_number=4)
print(output_number)
print(input_number)
```

A best practice in programming is to keep variable and function names very informative! Functions or classes can be made more informative by docstrings.

```{Python, engine.path='/usr/bin/Python3'}
def times3(input_number):
    """Multiplies input number times three.
    
    :input_number: input_number is an integer
    :returns: input_number * 3, input_number
    """
    outputNumber = input_number * 3
    return output_number, input_number
    
times3(input_number=4)

```

In this case docstrings are too much, but for larger functions or classes it is smart to have docstrings.

### Importing modules and packages
Python packages and modules are the bread and butter of Python. They make Python so great.
- Any Python file is a `module`, its name being the file's base name without the .py extension.
- A `package` is a collection of Python modules: a package is a directory of Python modules containing an additional __init__.py file, to distinguish a package from a directory that just happens to contain a bunch of Python scripts. Packages can be nested to any depth, provided that the corresponding directories contain their own __init__.py file.

```{Python, engine.path='/usr/bin/Python3'}
import math
print(dir(math)) #show names in math module
```

Basically there are three ways to load a package:
```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
import math
print(math.pi)

from math import pi
print(pi)

import numpy as np
print(np.pi)
```

> **Question 5**: Which is the best way to import modules?

### Some important internal modules:

- `os`: Access to operating system features
- `os.path`: Manipulating of file names
- `sys`: System specific configuration
- `glob`: Filename pattern matching
- `math`: Mathametical functions
- `datetime`: Date/Time manipulation

> **Question 6**: What is the difference between `os` and `os.path`?

Some examples:

```{Python, engine.path='/usr/bin/Python3'}
import glob
glob.glob("*")
```

```{Python, engine.path='/usr/bin/Python3'}
from datetime import timedelta, date
delta = timedelta(days=7)
print(date.today())
print(date.today()+delta)
```

### File access

File access is very simple for 99% of the cases. Write to a file and read from the same file with two simple lines. It is a best practice to use `with open` instead of `open` since it automatically closes the file. 

```{Python, eval=FALSE, engine.path='/usr/bin/Python3'}
with open('test.txt','w') as file:
    file.write('some simple text')
```


```{Python, eval=FALSE, engine.path='/usr/bin/Python3'}
with open('test.txt','r') as file:
    read_data = file.read()
print(read_data)
```

> **Question 7**: What does `w` and `r` mean?

### Error handling

Sometime problems occur... Errors detected during execution are called *exceptions*. Good programmers and good code deal with exceptions.

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
open("/foo0")
```

The file doesn't exist, so the script stops and outputs an informative message saying there is no file found. If you want to script error handling yourself:

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
try:
    open("/foo")
except FileNotFoundError as err:
    print(err.args)
    raise
```


### Functional and object-oriented programming
Until now in `R` you have used functional programming. Functional programming is a programming paradigm, that treats computation as the evaluation of functions and avoids changing-state and mutable data. In `Python` functional and object-oriented programming are both common. Python uses classes to be object-oriented. Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.

An [example on Datacamp ](https://www.datacamp.com/community/tutorials/python-oop-tutorial) helps to explain the OOP concept. Take a class Dog. Don't think of the dog as a specific dog. We're describing what a dog in general is and can do. Dogs usually have a name and age; these are instance attributes. Dogs can also bark; this is a method. Create a general dog class by making a class with two attributes: name and age.

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
class Dog:

    def __init__(self, name, age):  
        self.name = name
        self.age = age
```

Now specify the name and age of a dog and add it to an object. To access an object's attributes in Python, you can use the dot notation. This is done by typing the name of the object, followed by a dot and the attribute's name.

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
ozzy = Dog("Ozzy", 2)
print(ozzy.name + " is " + str(ozzy.age) + " year(s) old.")
```

We have a Dog class, it does have a name and age which you can keep track of, but it doesn't actually do anything. This is where instance methods come in. You can rewrite the class to now include a bark() and doginfo() method. 

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
class Dog:

    def __init__(self, name, age):  
        self.name = name
        self.age = age

    def bark(self):
        print("bark bark!")
    
    def doginfo(self):
        print(self.name + " is " + str(self.age) + " year(s) old.")
```

Great. Now we can call the methods in a similar way as the attributes with the dot notation.

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
ozzy = Dog("Ozzy", 2)
ozzy.bark()
ozzy.doginfo()
```

With OOP, your code will grow in complexity as your program gets larger. You will have different classes, subclasses, objects, inheritance, instance methods, and more. You'll want to keep your code properly structured and readable. During Geo-scripting we mostly perform functional programming to keep things simple. Sometimes class objects of modules will be used, such as a DataFrame in Pandas or a GeoDataFrame in GeoPandas. You don't have to develop these classes, but you should know how to handle classes.

### Visualization

Jupyter Notebooks can directly display output of your code, such as graphs, images and maps in the notebook. A lot of cool visualizations including Python source code are available from the [Python Graph Gallery](https://Python-graph-gallery.com/). The gallery even has some nice maps. Before we can do the visualizations, we want to add some Python packages via the terminal. Start up a new terminal and activate the environment.

```{r, engine='bash', eval=FALSE}
conda install --name geoscripting matplotlib seaborn
```

We will make a graph with the `Seaborn` module and plot it with `Matplotlib`. Give it a try!

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
import matplotlib.pyplot as plt
import seaborn as sns

df = sns.load_dataset('iris')
 
sns.pairplot(df, kind = "reg", hue = "species")
plt.show()
```

Nice visualization huh! Good job. Now we want to make a more advanced map in Python with some markers and a way to measure the distance between markers. Some icons of the free font library [FontAwesome](https://fontawesome.com/icons) are used.

```{Python, engine.path='/usr/bin/Python3', eval=FALSE}
from folium.plugins import MeasureControl

wageningenMap = folium.Map(location=[51.9700000, 5.6666700],
                        tiles = "Stamen Terrain",
                        zoom_start = 12)

folium.Marker([51.987530, 5.666049],
              popup='Gaia at Wageningen University Campus',
              icon=folium.Icon(color='green',icon='university',prefix='fa')
             ).add_to(wageningenMap)
folium.Marker([51.978761, 5.663023], 
              popup='Shopping center Tarthorst',
              icon=folium.Icon(color='red', icon='fa-shopping-cart', prefix='fa') 
             ).add_to(wageningenMap)
folium.Marker([51.953589, 5.663216], 
              popup='Beach at Rhine',
              icon=folium.Icon(color='blue', icon='tint',prefix='fa') 
             ).add_to(wageningenMap)

wageningenMap.add_child(MeasureControl())

wageningenMap
```

### Exiting the Jupyter Notebook
Your Jupyter Notebook is automatically saved as an .ipynb file on your computer (extension comes from the historic name "IPython Notebook"). The notebook can be downloaded as a Python script, pdf or html. You can also save it manually. To exit a notebook properly, use *File* → *Close and Halt*.

By pressing Ctrl + c in the terminal where Jupyter Notebook server is running, you cancel the running process. The terminal goes back to command line and you can exit the virtual environment by typing `source deactivate`.

```{r, engine='bash', eval=FALSE}
source deactivate
```


# Assignment
The assignment for today was to finish the datacamp course: Intro to Python for Data Science. If you finished early and still want to write more scripts, then you can follow one of the fun tutorials below.

# More info
- [Official Python tutorial](https://docs.Python.org/3.7/contents.html)
- [Python Style guide ](https://gist.github.com/sloria/7001839)
- [Geo-Spatial Notebooks](https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks#earth-science-and-geo-spatial-data)




